import numpy as np
import scipy.special as sp
import tensorflow as tf

# Legendre-Gauss-Lobatto nodes and quadrature weights dictionaries
lgl_nodes = {
    1: [0],
    2: [-1, 1],
    3: [-1, 0, 1],
    4: [-1, -np.sqrt(1 / 5), np.sqrt(1 / 5), 1],
    5: [-1, -np.sqrt(3 / 7), 0, np.sqrt(3 / 7), 1],
    6: [-1, -np.sqrt(1 / 3 + 2 * np.sqrt(7) / 21), -np.sqrt(1 / 3 - 2 * np.sqrt(7) / 21),
        np.sqrt(1 / 3 - 2 * np.sqrt(7) / 21), np.sqrt(1 / 3 + 2 * np.sqrt(7) / 21), 1],
    7: [-1, -0.830223896278566929872, -0.468848793470714213803772,
        0, 0.468848793470714213803772, 0.830223896278566929872, 1],
    8: [-1, -0.8717401485096066153375, -0.5917001814331423021445,
        -0.2092992179024788687687, 0.2092992179024788687687,
        0.5917001814331423021445, 0.8717401485096066153375, 1],
    9: [-1, -0.8997579954114601573124, -0.6771862795107377534459,
        -0.3631174638261781587108, 0, 0.3631174638261781587108,
        0.6771862795107377534459, 0.8997579954114601573124, 1],
    10: [-1, -0.9195339081664588138289, -0.7387738651055050750031,
         -0.4779249498104444956612, -0.1652789576663870246262,
         0.1652789576663870246262, 0.4779249498104444956612,
         0.7387738651055050750031, 0.9195339081664588138289, 1],
    32: [-1, -0.9926089339727613593715, -0.9752946904827092280625,
         -0.9482848384172323780833, -0.9118499390637319040745,
         -0.8663524760126755198308, -0.8122447317774423445468,
         -0.7500644939366747977173, -0.6804297556155508159424,
         -0.6040325871484211261372, -0.5216322628815652906066,
         -0.4340477172018469396033, -0.342149406538881486254,
         -0.2468506588502053044162, -0.1490985968136474949144,
         -0.0498647250465932523063, 0.0498647250465932523063,
         0.1490985968136474949144, 0.2468506588502053044162,
         0.342149406538881486254, 0.434047717201846939603,
         0.5216322628815652906066, 0.6040325871484211261372,
         0.6804297556155508159424, 0.7500644939366747977173,
         0.8122447317774423445468, 0.8663524760126755198308,
         0.9118499390637319040745, 0.9482848384172323780833,
         0.9752946904827092280625, 0.9926089339727613593715, 1]
}

lgl_weights = {
    1: [2],
    2: [1, 1],
    3: [1 / 3, 4 / 3, 1 / 3],
    4: [1 / 6, 5 / 6, 5 / 6, 1 / 6],
    5: [1 / 10, 49 / 90, 32 / 45, 49 / 90, 1 / 10],
    6: [1 / 15, (14 - np.sqrt(7)) / 30, (14 + np.sqrt(7)) / 30,
        (14 + np.sqrt(7)) / 30, (14 - np.sqrt(7)) / 30, 1 / 15],
    7: [0.04761904761904761904762, 0.2768260473615659480107,
        0.4317453812098626234179, 0.487619047619047619048,
        0.4317453812098626234179, 0.2768260473615659480107,
        0.04761904761904761904762],
    8: [0.03571428571428571428571, 0.210704227143506039383,
        0.3411226924835043647642, 0.4124587946587038815671,
        0.4124587946587038815671, 0.3411226924835043647642,
        0.210704227143506039383, 0.03571428571428571428571],
    9: [0.02777777777777777777778, 0.1654953615608055250463,
        0.2745387125001617352807, 0.3464285109730463451151,
        0.3715192743764172335601, 0.3464285109730463451151,
        0.2745387125001617352807, 0.1654953615608055250463,
        0.02777777777777777777778],
    10: [0.02222222222222222222222, 0.1333059908510701111262,
         0.2248893420631264521195, 0.2920426836796837578756,
         0.3275397611838974566565, 0.3275397611838974566565,
         0.292042683679683757876, 0.224889342063126452119,
         0.133305990851070111126, 0.02222222222222222222222],
    32: [0.002016129032258064516129, 0.01239810650137384378862,
         0.02219955288929196462383, 0.0317751354109154657816,
         0.0410342015860627233304, 0.049885271336221207012,
         0.0582404972480558695508, 0.066016877257154543932,
         0.0731371396026790326404, 0.0795305256921062522924,
         0.0851334979496682305275, 0.0898903729573578330721,
         0.0937538755468138135659, 0.09668560894800260056038,
         0.0986564365407617771707, 0.0996467715012767776349,
         0.099646771501276777635, 0.098656436540761777171,
         0.09668560894800260056, 0.093753875546813813566,
         0.089890372957357833072, 0.0851334979496682305275,
         0.0795305256921062522924, 0.0731371396026790326404,
         0.0660168772571545439324, 0.0582404972480558695508,
         0.049885271336221207012, 0.0410342015860627233304,
         0.031775135410915465782, 0.0221995528892919646238,
         0.0123981065013738437886, 0.002016129032258064516129]
}


class GridX:
    def __init__(self, order):
        self.order = int(order)
        self.nodes = self.get_nodes()
        self.weights = self.get_weights()
        self.eigenvalues = self.set_eigenvalues()

    def get_nodes(self):
        nodes = lgl_nodes.get(self.order, "nothing")
        return np.array(nodes)

    def get_weights(self):
        weights = lgl_weights.get(self.order, "nothing")
        return np.array(weights)

    def set_eigenvalues(self):
        # Legendre-Lobatto "eigenvalues"
        eigenvalues = np.array([(2.0 * s + 1) / 2.0 for s in range(self.order - 1)])

        # if self.order == 1:
        #    eigenvalues = 1 / 2
        return np.append(eigenvalues, (self.order - 1) / 2.0)

    def set_vandermonde_inverse(self):
        return np.array([[self.weights[j] * self.eigenvalues[s] * sp.eval_legendre(s, self.nodes[j])
                          # * sp.legendre(s)(self.nodes[j])
                          for j in range(self.order)]
                         for s in range(self.order)])

    def mass_matrix(self):
        # Diagonal part
        approx_mass = np.diag(self.weights)

        # Off-diagonal part
        p = sp.legendre(self.order - 1)
        v = np.multiply(self.weights, p(self.nodes))
        a = -self.order * (self.order - 1) / (2 * (2 * self.order - 1))
        # calculate mass matrix
        return approx_mass + a * np.outer(v, v)

    def advective_flux(self):
        # Compute internal flux array
        ar = np.zeros((self.order, self.order))
        for i in range(self.order):
            for j in range(self.order):
                ar[i, j] = self.weights[j] * sum(
                    (2 * s + 1) / 2 * sp.legendre(s)(self.nodes[i]) *
                    sp.legendre(s).deriv()(self.nodes[j]) for s in range(self.order))

        # Clear machine errors
        ar[np.abs(ar) < 1.0e-10] = 0

        return np.array(ar)

    def diffusive_flux(self):
        # Compute internal flux array
        ar = np.zeros((self.order, self.order))
        for i in range(self.order):
            for j in range(self.order):
                ar[i, j] = self.weights[j] * sum(
                    (2 * s + 1) / 2 * sp.legendre(s)(self.nodes[i]) *
                    sp.legendre(s).deriv().deriv()(self.nodes[j]) for s in range(self.order))

        # Clear machine errors
        ar[np.abs(ar) < 1.0e-10] = 0

        return np.array(ar)
